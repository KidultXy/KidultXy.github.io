import { __read } from "tslib";
import { degToRad } from '../util';
import { Bounds } from './bounds';
/**
 * Detect whether line-line collision.
 * From: https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
 */
function lineToLine(line1, line2) {
    var _a = __read(line1, 4), x0 = _a[0], y0 = _a[1], x1 = _a[2], y1 = _a[3];
    var _b = __read(line2, 4), x2 = _b[0], y2 = _b[1], x3 = _b[2], y3 = _b[3];
    var s10x = x1 - x0;
    var s10y = y1 - y0;
    var s32x = x3 - x2;
    var s32y = y3 - y2;
    var denom = s10x * s32y - s32x * s10y;
    if (denom === 0)
        return false;
    var denomPositive = denom > 0;
    var s02x = x0 - x2;
    var s02y = y0 - y2;
    var sNum = s10x * s02y - s10y * s02x;
    if (sNum < 0 === denomPositive)
        return false;
    var tNum = s32x * s02y - s32y * s02x;
    if (tNum < 0 === denomPositive)
        return false;
    if (sNum > denom === denomPositive || tNum > denom === denomPositive)
        return false;
    return true;
}
function intersectBoxLine(box /** 八个顶点 */, line) {
    var lines = [
        [box[0], box[1], box[2], box[3]],
        [box[2], box[3], box[4], box[5]],
        [box[4], box[5], box[6], box[7]],
        [box[6], box[7], box[0], box[1]],
    ];
    return lines.some(function (boxLine) { return lineToLine(line, boxLine); });
}
function getBounds(item, margin) {
    if (margin === void 0) { margin = [0, 0, 0, 0]; }
    var angle = item.getEulerAngles() || 0;
    item.setEulerAngles(0);
    // get dimensions
    var _a = item.getLocalBounds(), _b = __read(_a.min, 2), x = _b[0], y = _b[1], _c = __read(_a.max, 2), right = _c[0], bottom = _c[1];
    var _d = item.getBBox(), w = _d.width, h = _d.height;
    var height = h;
    var dx = 0;
    var dy = 0;
    var anchorX = x;
    var anchorY = y;
    if (item.tagName === 'text') {
        // [to fix] 目前 G 上计算 bbox 有一点误差
        height -= 1.5;
        var a = item.style.textAlign;
        var b_1 = item.style.textBaseline;
        dx = +item.style.dx;
        dy = +item.style.dy;
        // horizontal alignment
        if (a === 'center') {
            anchorX = (x + right) / 2;
        }
        else if (a === 'right' || a === 'end') {
            anchorX = right;
        }
        else {
            // left by default, do nothing
        }
        // vertical alignment
        if (b_1 === 'middle') {
            anchorY = (y + bottom) / 2;
        }
        else if (b_1 === 'bottom' || b_1 === 'baseline') {
            anchorY = bottom;
        }
    }
    var _e = __read(margin, 4), _f = _e[0], t = _f === void 0 ? 0 : _f, _g = _e[1], r = _g === void 0 ? 0 : _g, _h = _e[2], b = _h === void 0 ? t : _h, _j = _e[3], l = _j === void 0 ? r : _j;
    var bounds = new Bounds();
    bounds.set((dx += x) - l, (dy += y) - t, dx + w + r, dy + height + b);
    item.setEulerAngles(angle);
    return bounds.rotatedPoints(degToRad(angle), anchorX, anchorY);
}
export var IntersectUtils = { lineToLine: lineToLine, intersectBoxLine: intersectBoxLine, getBounds: getBounds };
export function intersect(a, b, margin) {
    var p = getBounds(a, margin);
    var q = getBounds(b, margin);
    var result = intersectBoxLine(q, [p[0], p[1], p[2], p[3]]) ||
        intersectBoxLine(q, [p[0], p[1], p[4], p[5]]) ||
        intersectBoxLine(q, [p[4], p[5], p[6], p[7]]) ||
        intersectBoxLine(q, [p[2], p[3], p[6], p[7]]);
    return result;
}
//# sourceMappingURL=intersect.js.map