"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LegendFilter = exports.attributesOf = exports.dataOf = exports.legendsOf = exports.itemsOf = exports.labelOf = exports.markerOf = exports.LEGEND_LABEL_CLASS_NAME = exports.LEGEND_MAKER_CLASS_NAME = exports.LEGEND_ITEMS_CLASS_NAME = exports.CATEGORY_LEGEND_CLASS_NAME = void 0;
const util_1 = require("@antv/util");
const helper_1 = require("../utils/helper");
const utils_1 = require("./utils");
exports.CATEGORY_LEGEND_CLASS_NAME = 'legend-category';
exports.LEGEND_ITEMS_CLASS_NAME = 'items-item';
exports.LEGEND_MAKER_CLASS_NAME = 'legend-category-item-marker';
exports.LEGEND_LABEL_CLASS_NAME = 'legend-category-item-label';
function markerOf(item) {
    return item.getElementsByClassName(exports.LEGEND_MAKER_CLASS_NAME)[0];
}
exports.markerOf = markerOf;
function labelOf(item) {
    return item.getElementsByClassName(exports.LEGEND_LABEL_CLASS_NAME)[0];
}
exports.labelOf = labelOf;
function itemsOf(root) {
    return root.getElementsByClassName(exports.LEGEND_ITEMS_CLASS_NAME);
}
exports.itemsOf = itemsOf;
function legendsOf(root) {
    return root.getElementsByClassName(exports.CATEGORY_LEGEND_CLASS_NAME);
}
exports.legendsOf = legendsOf;
function dataOf(root) {
    // legend -> layout -> container
    let parent = root.parentNode;
    while (parent && !parent.__data__) {
        parent = parent.parentNode;
    }
    return parent.__data__;
}
exports.dataOf = dataOf;
function attributesOf(root) {
    let child = root;
    while (child && !child.attr('class').startsWith('legend')) {
        child = child.children[0];
    }
    return child.attributes;
}
exports.attributesOf = attributesOf;
function legendFilter(root, { legends, // given the root of chart returns legends to be manipulated
marker: markerOf, // given the legend returns the marker
label: labelOf, // given the legend returns the label
datum, // given the legend returns the value
filter, // invoke when dispatch filter event,
state = {}, // state options
 }) {
    // Index handler by item.
    const itemClick = new Map();
    const itemPointerenter = new Map();
    const itemPointerout = new Map();
    const { unselected = {
        markerStroke: '#aaa',
        markerFill: '#aaa',
        labelFill: '#aaa',
    }, } = state;
    const markerStyle = { unselected: (0, helper_1.subObject)(unselected, 'marker') };
    const labelStyle = { unselected: (0, helper_1.subObject)(unselected, 'label') };
    const { setState: setM, removeState: removeM } = (0, utils_1.useState)(markerStyle, undefined);
    const { setState: setL, removeState: removeL } = (0, utils_1.useState)(labelStyle, undefined);
    const items = Array.from(legends(root));
    const selectedValues = items.map(datum);
    const updateLegendState = () => {
        for (const item of items) {
            const value = datum(item);
            const marker = markerOf(item);
            const label = labelOf(item);
            if (!selectedValues.includes(value)) {
                setM(marker, 'unselected');
                setL(label, 'unselected');
            }
            else {
                removeM(marker, 'unselected');
                removeL(label, 'unselected');
            }
        }
    };
    for (const item of items) {
        // Defined handlers.
        const pointerenter = () => {
            (0, utils_1.setCursor)(root, 'pointer');
        };
        const pointerout = () => {
            (0, utils_1.restoreCursor)(root);
        };
        const click = () => __awaiter(this, void 0, void 0, function* () {
            const value = datum(item);
            const index = selectedValues.indexOf(value);
            if (index === -1)
                selectedValues.push(value);
            else
                selectedValues.splice(index, 1);
            if (selectedValues.length === 0)
                selectedValues.push(...items.map(datum));
            yield filter(selectedValues);
            updateLegendState();
        });
        // Bind and store handlers.
        item.addEventListener('click', click);
        item.addEventListener('pointerenter', pointerenter);
        item.addEventListener('pointerout', pointerout);
        itemClick.set(item, click);
        itemPointerenter.set(item, pointerenter);
        itemPointerout.set(item, pointerout);
    }
    return () => {
        for (const item of items) {
            item.removeEventListener('click', itemClick.get(item));
            item.removeEventListener('pointerenter', itemPointerenter.get(item));
            item.removeEventListener('pointerout', itemPointerout.get(item));
        }
    };
}
function LegendFilter() {
    return (context, _, emitter) => {
        const { container, view, options: viewOptions, update } = context;
        const legends = legendsOf(container);
        const filter = (channel, value) => __awaiter(this, void 0, void 0, function* () {
            const { scale } = view;
            const { [channel]: scaleOrdinal } = scale;
            const { marks } = viewOptions;
            // Add filter transform for every marks,
            // which will skip for mark without color channel.
            const newMarks = marks.map((mark) => {
                const { transform = [] } = mark;
                const newTransform = [
                    { type: 'filter', [channel]: value },
                    ...transform,
                ];
                return (0, util_1.deepMix)({}, mark, {
                    transform: newTransform,
                    // Set domain of scale to preserve legends.
                    scale: {
                        [channel]: {
                            domain: scaleOrdinal.getOptions().domain,
                        },
                    },
                });
            });
            const newOptions = Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
            return update(newOptions);
        });
        if (!legends.length) {
            const onFilter = (options) => {
                const { values, channel } = options;
                filter(channel, values);
            };
            emitter.on('legend:filter', onFilter);
            return () => {
                emitter.off('legend:filter', onFilter);
            };
        }
        const removes = legends.map((legend) => {
            const { name: channel, domain } = dataOf(legend).scales[0];
            return legendFilter(container, {
                legends: itemsOf,
                marker: markerOf,
                label: labelOf,
                datum: (d) => {
                    const { __data__: datum } = d;
                    const { index } = datum;
                    return domain[index];
                },
                filter: (value) => filter(channel, value),
                state: legend.attributes.state,
            });
        });
        return () => {
            removes.forEach((remove) => remove());
        };
    };
}
exports.LegendFilter = LegendFilter;
//# sourceMappingURL=legendFilter.js.map